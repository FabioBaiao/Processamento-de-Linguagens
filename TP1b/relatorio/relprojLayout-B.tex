%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%
\documentclass{report}
\usepackage[portuges]{babel}
%\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}

\usepackage{url}
\usepackage{enumerate}
\usepackage{graphicx}

%\usepackage{alltt}
%\usepackage{fancyvrb}
\usepackage{listings}
%LISTING - GENERAL
\lstset{
    basicstyle=\small,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    frame=tB,
    mathescape=true,
    escapeinside={(*@}{@*)}
}
%
%\lstset{ %
%   language=Java,                          % choose the language of the code
%   basicstyle=\ttfamily\footnotesize,      % the size of the fonts that are used for the code
%   keywordstyle=\bfseries,                 % set the keyword style
%   %numbers=left,                          % where to put the line-numbers
%   numberstyle=\scriptsize,                % the size of the fonts that are used for the line-numbers
%   stepnumber=2,                           % the step between two line-numbers. If it's 1 each line
%                                           % will be numbered
%   numbersep=5pt,                          % how far the line-numbers are from the code
%   backgroundcolor=\color{white},          % choose the background color. You must add \usepackage{color}
%   showspaces=false,                       % show spaces adding particular underscores
%   showstringspaces=false,                 % underline spaces within strings
%   showtabs=false,                         % show tabs within strings adding particular underscores
%   frame=none,                             % adds a frame around the code
%   %abovecaptionskip=-.8em,
%   %belowcaptionskip=.7em,
%   tabsize=2,                              % sets default tabsize to 2 spaces
%   captionpos=b,                           % sets the caption-position to bottom
%   breaklines=true,                        % sets automatic line breaking
%   breakatwhitespace=false,                % sets if automatic breaks should only happen at whitespace
%   title=\lstname,                         % show the filename of files included with \lstinputlisting;
%                                           % also try caption instead of title
%   escapeinside={\%*}{*)},                 % if you want to add a comment within your code
%   morekeywords={*,...}                    % if you want to add more keywords to the set
%}

\usepackage{xspace}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\def\darius{\textsf{Darius}\xspace}
\def\antlr{\texttt{AnTLR}\xspace}
\def\pe{\emph{Publicação Eletrónica}\xspace}

\def\titulo#1{\section{#1}}
\def\super#1{{\em Supervisor: #1}\\ }
\def\area#1{{\em \'{A}rea: #1}\\[0.2cm]}
\def\resumo{\underline{Resumo}:\\ }


%%%%\input{LPgeneralDefintions}

\title{Processamento de Linguagens (3º Ano MIEI)\\ \textbf{Trabalho Prático 1b - FLEX}\\ Relatório de Desenvolvimento}
\author{Fábio Luís Baião da Silva\\ (A75662) \and João da Cunha Coelho\\ (A74859) \and Luís Miguel Moreira Fernandes\\ (A74748) }
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
O Flex foi criado em 1987 pelo professor de Ciências da Computação da Universidade da Califórnia, Vern Edward Paxson e surge como alternativa grátis e \textit{open-source} ao Lex. É um programa que gera analisadores léxicos (também conhecidos como \textit{scanners}) com inúmeras utilidades para o dia-a-dia da população.\\
É frequentemente usado junto do gerador de \textit{parser yacc} nos sistemas operativos \textit{BSD-derived}.
\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}

O primeiro contacto com o gerador Flex despertou grande curiosidade, uma vez que consiste em filtros a aplicar a textos que tornam o reconhecimento e análise mais fácil e intuitiva. O uso da linguagem C ao gerar filtros em Flex é, também, de grande utilidade, sendo que é uma linguagem já conhecida e trabalhada ao longo do curso.

Quanto ao tema, a escolha recaiu sobre o tema \textbf{2.4. Processador de Named Entities}, devido à clareza do enunciado e à dimensão das dificuldades que este nos poderia trazer e que gostaríamos de conseguir superar, no entanto também desenvolvemos uma solução para o tema \textbf{2.1 Processador de Inglês Corrente}, que também merecerá uma secção própria neste relatório.

\cleardoublepage

\chapter{Processador de Named Entities} \

\section{Estrutura do Ficheiro XML} \
De seguida, é sucintamente explicada a estrutura do dialeto XML chamado \textit{ENAMEX}, em análise neste trabalho.\\

{\footnotesize
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<document>
<ENAMEX> Vivia </ENAMEX> este herói no <ENAMEX TYPE="CITY"> Rio de
Janeiro </ENAMEX>, <ENAMEX TYPE="COUNTRY">Brasil</ENAMEX> e era
professor não se sabe de que doutrinas no ano de
<TIMEX TYPE="DATE"> 1710 </TIMEX>, quando os franceses comandados por
<ENAMEX TYPE="PERSON"> Duclerc </ENAMEX>, atacaram a cidade.
O governador portou-se mal, e permanecia numa deplorável inacção, quando
<ENAMEX TYPE="PERSON"> Bento do Amaral </ENAMEX> à frente dos seus
estudantes e de paisanos armados, saiu a tomar o passo aos invasores,
repelindo-os energicamente, e dando lugar a que o ataque se malograsse
e os agressores ficassem prisioneiros.
<ENAMEX> Não </ENAMEX> tardou <ENAMEX TYPE="PERSON"> Dugua-Trouin </ENAMEX>
a vir tomar a desforra.
</document>
\end{verbatim}
}

As etiquetas \textit{ENAMEX} e \textit{TIMEX} permitem identificar, respetivamente, entidades representadas pelo nome próprio ou datas. Como podemos ter cidades, pessoas ou países representados pelo nome próprio, associa-se também um tipo à etiqueta.


\chapter{Apresentação da Solução} \label{ae}

\section{Análise do problema}
Perante a necessidade de escrever um processador capaz de analisar um documento como o mencionado acima e produzir um índice HTML para cada um dos tipos da etiqueta \textit{ENAMEX}, começou-se por definir a estrutura usada para armazenar os nomes próprios de cada tipo, durante o processamento do ficheiro. A escolha recaiu pelo uso de árvores binárias balanceadas, uma por tipo, particularmente os \textit{trees} da biblioteca \textbf{GLib}, por facilidade de utilização e por terem sido abordados em aulas práticas. No entanto, a principal razão é a de se pretender saber o número de ocorrências para cada nome próprio. Uma vez que cada nodo da árvore é um par chave-valor, é possível guardar, para cada chave, o número de ocorrências.

\begin{verbatim}
GTree *cidades, *paises, *pessoas;
\end{verbatim}

Para determinar o maior e o menor ano mencionados no texto criaram-se duas variáveis, uma para cada ano, cujo valor será controlado por intermédio de comparações de valor, à medida que vamos percorrendo o ficheiro.

\begin{verbatim}
int menor = 0;
int maior = 0;

(...)

void setLimites(int ano){
    if (ano < menor || menor == 0) menor = ano;
    if (ano > maior || maior == 0) maior = ano;
}
\end{verbatim}

Além destes dois indicadores, decidiu-se criar também um índice HTML que indica todas as datas mencionadas. Para isso, utilizou-se arrays (mais concretamente \textit{pointer arrays}) da biblioteca GLib como estrutura para armazenar as datas.

\begin{verbatim}
GPtrArray *datas;
\end{verbatim}

\section{Regras definidas}

O comportamento a adotar em cada entidade depende da etiqueta correspondente. Assim, para simplificar a escrita do programa, criou-se uma start condition para cada etiqueta. Para cada caso de "abertura" é iniciada a start condition respetiva. 

\begin{verbatim}
%x CIDADE PAIS DATA PESSOA

(...)

\<ENAMEX\ TYPE=\"CITY\"\>       {BEGIN(CIDADE);}
\<ENAMEX\ TYPE=\"COUNTRY\"\>    {BEGIN(PAIS);}
\<ENAMEX\ TYPE=\"PERSON\"\>     {BEGIN(PESSOA);}
\<TIMEX\ TYPE=\"DATE\"\>        {BEGIN(DATA);}
\end{verbatim}

Desta forma, torna-se mais fácil controlar as regras que são testadas. As regras para cada tipo de nomes próprios são muito idênticas, variando na estrutura de dados em que os dados são inseridos.

\begin{verbatim}
<CIDADE>{ELEMENTO}                      {   char *chave = strdup(yytext);
                                            paragrafo2Espaco(chave);
                                            inserir(cidades, chave);}
<PAIS>{ELEMENTO}                        {   char *chave = strdup(yytext);
                                            paragrafo2Espaco(chave);
                                            inserir(paises, chave);}
<PESSOA>{ELEMENTO}                      {   char *chave = strdup(yytext);
                                            paragrafo2Espaco(chave);
                                            inserir(pessoas, chave);}
\end{verbatim}

O ELEMENTO é uma definição criada na primeira secção. Consiste numa PALAVRA seguida de 0 ou mais conjuntos de espaço/newline e PALAVRA. Por sua vez, uma PALAVRA é uma sequência de uma ou mais LETRA. Por fim, uma LETRA é definida por todas as letras do alfabeto (minúsculas e maiúsculas) e outros caracteres relevantes.

\begin{verbatim}
LETRA       [a-zA-Z]|-|\.|ó|ã|ç|à|á|é|ê|ú|í|õ
PALAVRA     {LETRA}+
ELEMENTO    {PALAVRA}([ \n]{PALAVRA})*
\end{verbatim} 

A função "paragrafo2Espaco" converte os "\textbackslash n" encontrados, em espaços. 
A função "inserir" insere um nome próprio com o valor 1 caso ainda não existe na árvore respetiva. Se já existir apenas incrementa o valor correspondente à chave.

\begin{verbatim}
void paragrafo2Espaco(char *chave){
    int i, n = strlen(chave);
    for (i = 0; i < n; i++){
        if (chave[i] == '\n'){
            chave[i] = ' ';
        }
    }
}

void inserir(GTree *arvore, char *chave){
    int *valor = g_tree_lookup(arvore, chave);
    if (valor != NULL){
        (*valor)++;
    }
    else{
        valor = malloc(sizeof(int));
        *valor = 1;
    }
    g_tree_insert(arvore, chave, valor);
}
\end{verbatim} 

Para o caso das datas, estas podem aparecer em formatos diferentes. Os formatos encontrados foram: \textit{ano}; \textit{dia/mes/ano}; \textit{dia} de \textit{mes}; \textit{mes}. Nos dois últimos casos, o mês aparece escrito por extenso. 
Qualquer que seja o formato, é necessário guardar o padrão encontrado no array. Esse comportamento é descrito da mesma forma para todos os formatos. No entanto, como os dois primeiros formatos enunciados contêm o ano, usa-se a função "setLimites" (referida anteriormente) para definir os anos mais antigo/recente. 
Para além disso, uma vez que não é possível saber o número de elementos no array, é necessário um contador para permitir saber o número de elementos inseridos.

\begin{verbatim}
<DATA>({NUM}[ \n])?{ELEMENTO}           {   char *v = strdup(yytext);
                                            paragrafo2Espaco(v);
                                            g_ptr_array_add(datas, v);
                                            nDatas++;
                                            }
<DATA>{NUM}\/{NUM}\/{NUM}               {   char *v = strdup(yytext);
                                            g_ptr_array_add(datas, v);
                                            nDatas++;
                                            char sep[2] = "/";
                                            char *token = strtok(yytext, sep);
                                            token = strtok(NULL, sep);
                                            token = strtok(NULL, sep);
                                            v = strdup(token);
                                            int ano = atoi(v);
                                            setLimites(ano);}
<DATA>{NUM}                             {   char *v = strdup(yytext);
                                            g_ptr_array_add(datas, v);
                                            nDatas++;
                                            int ano = atoi(yytext);
                                            setLimites(ano);}
\end{verbatim} 

O NUM consiste numa sequência de um ou mais números.

\begin{verbatim}
NUM         [0-9]+
\end{verbatim}

\section{Resultados}

Para a apresentação de resultados, e ignorando o código necessário para gerar as páginas HTML, é necessário iterar pelas estruturas de dados. 
No caso das datas basta iterar de 0 até ao número de elementos inseridos. Para os nomes próprios, uma vez que estão guardados em árvores, não é possível iterar a partir de indíces. Assim, foi necessário criar uma função que realize as operações desejadas para cada nodo, para que seja usada pela função \verb|g_tree_foreach|. Esta função, para além de receber a chave e o valor respetivo, recebe ainda o ficheiro para onde terá de escrever os dados.

\begin{verbatim}
int i;
for(i = 0; i < nDatas; i++) {
    char *v = g_ptr_array_index(datas, i);
    /* operações */
}

------

gboolean printNodo(gpointer key, gpointer value, gpointer data) {
    /* operações */
    return FALSE;
}

(...)

g_tree_foreach(arvore, (GTraverseFunc)printNodo, f);

\end{verbatim}


\chapter{Apresentação de Resultados}

Neste capítulo serão apresentados exemplos de utilização.

\section{Execução}

A execução do programa é feita da seguinte forma:

\begin{verbatim}
./entidades ficheiro.xml
\end{verbatim}

O programa abre automaticamente o menu principal realtivo ao ENAMEX no browser firefox. Se este browser não estiver instalado terá de se abrir o ficheiro Enamex.html que é criado na pasta layout com o browser pretendido.

\section{Exemplos}

Os exemplos que serão mostrados de seguida foram obtidos usando uma adaptação do ficheiro exemplo-Enamex.xml fornecido pela equipa docente.

Abrindo o menu principal aparece o seguinte resultado:

\begin{figure}[h]
\centering
\includegraphics[width=120mm, scale=0.5]{Enamex.png}
\caption{\label{fig:change}Menu de Enamex.}
\end{figure}

Utilizando o menu de navegação superior para clicar em TIMEX, obtem-se a página relativa às datas. 
Estando na página relativa aos nomes próprios é possível consultar, a partir do menu lateral, os dados relativos às pessoas, cidades ou países.
Da mesma forma, é possível consultar os limites e as datas estando na página relativa às datas.

\begin{figure}[h]
\centering
\includegraphics[width=120mm, scale=0.5]{Timex.png}
\caption{\label{fig:change}Menu de Timex.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=120mm, scale=0.5]{Pessoas.png}
\caption{\label{fig:change}Lista de pessoas referidas.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=120mm, scale=0.5]{Cronologia.png}
\caption{\label{fig:change}Anos mais antigo e recente referidos.}
\end{figure}


\chapter{Processador de inglês corrente} \label{ingles}

A primeira etapa da resolução deste problema foi tornar o filtro FLEX capaz de detetar as contrações de uso corrente e constante, tais como \textit{It's}, \textit{I'm}, \textit{You're}, entre outras. Sem a cobertura destes casos seria difícil considerar positiva a solução desenvolvida pelo grupo, mas com expressões como as que se podem ver na figura abaixo foi possível alcançar bons resultados.
%imagem das contraçoes correntes
\begin{figure}[h]
\centering
\includegraphics[width=120mm, scale=0.5]{MostUsedContractions.png}
\caption{\label{fig:change}Contrações mais recorrentes.}
\end{figure}

Há, porém, situações em que surge dúvida sobre a palavra contraída, uma vez que a contração pode representar dois vocábulos diferentes. Um exemplo é a contração \textit{'ll}, que pode comprimir tanto \textit{will} como \textit{shall}. Em abreviaturas dúbias como esta, optou-se por moldar o processador no sentido de substituir a contração pelas várias palavras que pode representar, separadas por /, cabendo depois ao utilizador fazer o seu juízo de valor e editar, se assim o preferir, a solução dada pelo programa, algo permitido pelo HTML no qual é exposto o texto de \textit{output}.
%imagem dos will/shall
\begin{figure}[h]
\centering
\includegraphics[width=120mm, scale=0.5]{MultipleOption.png}
\caption{\label{fig:change}Contrações com múltiplas opções.}
\end{figure}

Em seguida procurou-se a cobertura de contrações não tão frequentes, como \textit{gonna}, \textit{wanna} e outras sugeridas por uma breve pesquisa na web, e passou-se à segunda etapa da resolução do problema: a listagem dos verbos utilizados no infinitivo no texto ao qual se aplica o processador FLEX. A definição da estrutura onde seriam armazenados os verbos, ao longo do processamento da análise do ficheiro de \textit{input}, foi o primeiro passo. A escolha recaiu sobre as árvores da biblioteca GLib, à semelhança do que acontecera na resolução da solução para o problema dos processadores de Named Entities, porque pretendia-se evitar que um mesmo verbo fosse introduzido na estrutura mais do que uma vez. Assim, cada chave de um nodo na árvore representa um verbo e o valor o número de ocorrências desse mesmo verbo, ou seja, sempre que se encontra um verbo repetido, este não é inserido, apenas se incrementa o valor do nodo. Na Fig. 6.4 está a função responsável pela inserção na árvore. Nota também para a contagem do número de verbos identificados, através de uma variável \textit{n}, para controlo do número de verbos repetidos encontrados e, assim, não introduzidos - a diferença entre n e o número de elementos na árvore resulta no número de verbos repetidos identificados pelo processador de texto.
%imagem da estrutura
\begin{figure}[h]
\centering
\includegraphics[width=30mm, scale=0.5]{tree+n.png}
\caption{\label{fig:change}Estrutura usada e variável auxiliar.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=120mm, scale=0.5]{function.png}
\caption{\label{fig:change}Função de inserção na árvore de verbos.}
\end{figure}

\newpage
Chegou, então, a altura de pensar em que situações se usam verbos no infinitivo. Tal como consta no enunciado, os casos mais óbvios serão aqueles em que o verbo é usado com \textit{to} atrás ou quando surgem associados a palavras como \textit{do} ou \textit{did}, porém existem outras situações que o grupo procurou cobrir - a seguir a contrações como \textit{gonna} e \textit{wanna} ou a seguir a frases interrogativas com verbos modais (\textit{should}, \textit{may}, \textit{must}, etc.), por exemplo, a frase requer um verbo no infinitivo.
%imagem das questoes
\begin{figure}[h]
\centering
\includegraphics[width=120mm, scale=0.5]{questions.png}
\caption{\label{fig:change}Cobertura de verbos nas questões.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=120mm, scale=0.5]{questionsUse.png}
\caption{\label{fig:change}Inclusão dos verbos, usando as definições acima.}
\end{figure}

Nesta questão dos verbos há novamente um senão. Começando pelo facto de a palavra \textit{to} não ser usada apenas como antecessor de verbos, mas também como preposição, cria logo a necessidade de excluir diversos casos. Uma frase exemplo: \textit{I want to give a present to Anthony's brother.} - nesta frase temos dois \textit{to}, um que precede o verbo \textit{want} e outro que precede um complemento indireto. Apesar de ser díficil cobrir todas as situações, através da representação das exceções (Fig. 6.5) e das situações em que se segue letra maiúscula, números ou sinais de pontuação a um \textit{to}, consegue-se que a maioria dos \textit{to} seja corretamente identificada como verbo ou preposição.
%imagem dos casos excluídos
\begin{figure}[h]
\centering
\includegraphics[width=130mm, scale=0.5]{exceptions.png}
\caption{\label{fig:change}Algumas palavras que, não sendo verbos, podem suceder a um \textit{to}.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=120mm, scale=0.5]{falseTos.png}
\caption{\label{fig:change}Casos em que o \textit{to} não antecede um verbo.}
\end{figure}

Por fim, para aumentar a área de atuação do processador FLEX, decidiu-se colocar algumas abreviaturas, para além de contrações, no lote de expressões regulares filtradas.
%imagem das abreviaturas
\begin{figure}[h]
\centering
\includegraphics[width=150mm, scale=0.5]{abreviations.png}
\caption{\label{fig:change}Abreviaturas incluídas.}
\end{figure}


\chapter{Apresentação de Resultados}

Neste capítulo serão apresentados exemplos de utilização.

\section{Execução}

A conversão de inglês corrente envolve as seguintes etapas:

\begin{enumerate}
    \item Colar o texto a converter na caixa de texto;
    \item Confirmar o armazenamento num ficheiro;
    \item Correr o programa FLex;
    \item Ver resultados.
\end{enumerate}

\section{Exemplos}

Agora apresentar-se-ão os resultados da aplicação quando recebeu como \textit{input} os seguintes textos:

\begin{enumerate}
    \item FAQ-Python-En.txt, fornecido pela equipa docente aquando do lançamento deste enunciado;
    \item HP-e-a-Camara-dos-Segredos-Cap1-FirstParagraphs.txt.
\end{enumerate}

\subsection{FAQ-Python-En.txt}

Relativamente ao primeiro caso, a quantidade de contrações é reduzida apesar do tamanho do texto. O processador alcança bons resultados, quer nos verbos listados quer no texto sem contrações, no entanto sobressaem dois erros recorrentes:

\begin{enumerate}
    \item a colocação por extenso da contração \textit{'s} quando esta atua enquanto símbolo de posse (\textit{possessive 's}). Este é o tipo de erro difícil de combater, visto que \textit{'s} pode ser usado como contração de \textit{is} ou \textit{has}, mas também no contexto de posse (\textit{Anthony's house is red.});
    \item a inclusão de advérbios na listagem de verbos, resultante de frases do género de \textit{He has to seriously consider it!}, onde o advérbio toma a posição do verbo, isto é, a seguir ao \textit{to}, perturbando a eficácia do processador.
\end{enumerate} 

\begin{figure}[h]
\centering
\includegraphics[width=120mm, scale=0.5]{adverbError.png}
\caption{\label{fig:change}Advérbio na listagem de verbos.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=100mm, scale=0.5]{verbsList.png}
\caption{\label{fig:change}Excerto da listagem de verbos.}
\end{figure}

\newpage
\subsection{HP-e-a-Camara-dos-Segredos-Cap1-FirstParagraphs.txt}

Para além do Ficheiro disponibilizado para teste, decidimos exmplificar a utilização do programa com um outro:

\begin{figure}[h!]
\centering
\includegraphics[width=120mm, scale=0.5]{InputExample2.png}
\caption{\label{fig:change}Input Exemplo 2.}
\end{figure}


Vemos em cima o texto de input sobre o qual o programa irá expandir as contrações, bem como listar os verbos no infinitivo e na imagem que se segue o output gerado pelo programa FLex.
\newpage

\begin{figure}[h!]
\centering
\includegraphics[width=120mm, scale=0.5]{OutputExample2.png}
\caption{\label{fig:change}Output Exemplo 2.}
\end{figure}

É possível verificar que as contrações foram expandidas quase na perfeição. Mais uma vez, e como já foi dito anteriormente, a contração \textit{'s} quando atua como símbolo de posse volta a ser um erro complicado de ultrapassar.
Podemos ver também de seguida os verbos no infinitivo que foram retirados.

\begin{figure}[h!]
\centering
\includegraphics[width=120mm, scale=0.5]{VerbosExample2.png}
\caption{\label{fig:change}Excerto da listagem de verbos no Exemplo 2.}
\end{figure}

Tal como aconteceu anteriormente com o advérbio "explicitly", desta vez o advérbio "just" é apanhado na posição do verbo e, como já referido, perturba a eficácia do processador.


\chapter{Conclusão} \label{concl}
Terminado o projeto, salientamos a utilidade e facilidade do uso do Flex na criação de filtros a aplicar a textos, algo que se tornaria bem mais complexo se contruíssemos e utilizássemos um programa em C ou noutra linguagem de programação mais comum.\\
Mais uma vez, como no TP1a - GAWK, é de destacar a criação de uma página HTML, que, apesar de já ter sido também criada para o trabalho referido, permanece algo novo entre o grupo e ainda assim com resultados, na nossa perspetiva, bastante satisfatórios.\\
Quanto a trabalho futuro, seria lógico, no caso do Exercício 2.1., continuar a desenvolver casos para tentar aproximar da perfeição o filtro. Da mesma forma, falando agora sobre o trabalho futuro para o Exercício 2.4., será lógico que o próximo passo seja a criação de mais Tags que possam ser incluídas no ficheiro XML e identificadas pelo filtro Flex.


\end{document} 